<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>urllib3 on Hackrole's Blog</title><link>https://hackrole.github.io/categories/urllib3/</link><description>Recent content in urllib3 on Hackrole's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2020 &lt;a href="https://www.wangchucheng.com/">C. Wang&lt;/a> and &lt;a href="https://www.ruiqima.com/">R. Ma&lt;/a></copyright><lastBuildDate>Tue, 05 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://hackrole.github.io/categories/urllib3/index.xml" rel="self" type="application/rss+xml"/><item><title>source read</title><link>https://hackrole.github.io/post/urllib3_source_read/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://hackrole.github.io/post/urllib3_source_read/</guid><description>TODOadd lib to auto-read python lib, make plantuml file plantuml graph class graph @startuml class RequestMethods { __init__(headers) urlopen(method: str, url: str, body, headers, encode_multipart, **kw) -&amp;gt; BaseHTTPResposne request(method: str, url: str, body, fields, headers, json, **urlopen_kw) -&amp;gt; BaseHTTPResposne request_encode_url(method, url, fields, headers, **urlopen_kw) -&amp;gt; BaseHTTPResposne request_encode_body(method, url, fields, headers, encode_multipart: bool, **urlopen_kw) -&amp;gt; BaseHTTPResposne } class ContentDecoder { decompress(self, data: btyes) -&amp;gt; bytes flush(self) -&amp;gt; bytes } class DeflateDecoder { decompress(self, data: bytes) -&amp;gt; bytes flush(self) -&amp;gt; bytes } enum GzipDecoderState { FIRST_MEMBER OTHER_MEMBERS SWALLOW_DATA } class GzipDecoder { decompress(self, data: bytes) -&amp;gt; bytes flush(self) -&amp;gt; bytes } class BrotliDecoder { flush(self) -&amp;gt; bytes } class MultiDecoder { list[ContentDecoder] _decoders decompress(self, data: bytes) -&amp;gt; bytes flush(self) -&amp;gt; bytes } ContentDecoder &amp;lt;|-- DeflateDecoder ContentDecoder &amp;lt;|-- GzipDecoder ContentDecoder &amp;lt;|-- BrotliDecoder ContentDecoder &amp;lt;|-- MultiDecoder class BaseHTTPResposne { abstract data : property abstract url : property abstract closed : property abstract HTTPConnection connection : property get_redirect_location(self) -&amp;gt; Union[None, str, False] json() -&amp;gt; Any abstract stream(amt: Optional[int] decode_content: Optional[bool]) -&amp;gt; Iterator[bytes] abstract read(amt: Optional[int], decode_content: Optional[bool], cache_content: bool) -&amp;gt; bytes abstract read_chunked(self, amt: Optional[int], decode_content: Optional[bool]) -&amp;gt; Iterator[bytes] abstract release_conn(self) -&amp;gt; None abstract draion_conn(self) -&amp;gt; None abstract close(self) -&amp;gt; None _init_decoder(self) -&amp;gt; None _decode(self, data: bytes, decode_content: Optional[bool], flush_decoder: bool) -&amp;gt; bytes _flush_decoder(self) -&amp;gt; bytes readable(self) -&amp;gt; bool readinto(self, b: bytearray) -&amp;gt; int getheaders(self) -&amp;gt; List[Tuple[str, str]] getheader(self, name: str, default: Optional[str] = None) -&amp;gt; Optional[str] info(self) -&amp;gt; HTTPHeaderDict geturl(self) -&amp;gt; Optional[Union[str, Literal[False]]] } class HTTPResponse { data : property url: property connection : property release_conn(self) -&amp;gt; None draion_conn(self) -&amp;gt; None is_closed(self) -&amp;gt; bool tell(self) -&amp;gt; int _init_length(self, request_method: Optional[str]) -&amp;gt; Optional[int] _error_catcher(self) -&amp;gt; Generator(None, None, None) : contextmanager read(self, amt: Optional[int], decode_content: Optional[bool] = None, cache_content: bool = False) -&amp;gt; bytes stream(amt: Optional[int] decode_content: Optional[bool]) -&amp;gt; Iterator[bytes] classmethod from_httplib(ResponseCls, r: HttpLibHTTPResponse, **response_kw: Any) -&amp;gt; HTTPResponse close(self) -&amp;gt; None closed(self) -&amp;gt; bool :property fileno(self) -&amp;gt; int flush(self) -&amp;gt; None supports_chunked_read(self) -&amp;gt; bool _update_chunk_length(self) -&amp;gt; None _handle_chunk(self, amt: Optional[int]) -&amp;gt; bytes read_chunked(self, amt: Optional[int], decode_content: Optional[bool] = None) -&amp;gt; Generator[bytes, None, None] __iter__(self) -&amp;gt; Iterator[bytes] } BaseHTTPResposne &amp;lt;|-- HTTPResponse @enduml @startuml enum _Sentinel { not_passed } class RecentUsedContainer { } class HTTPHeaderDictItemView { HTTPHeaderDict _headers } class HTTPHeaderDict { } @enduml pool_manager @startuml class PookKey { key_scheme key_host key_port key_timeout key_retries key_block key_source_address key_key_file key_key_password key_cert_file key_cert_reqs key_ca_certs key_ssl_version key_ssl_minimum_version key_ssl_maximum_version key_ca_cert_dir key_ssl_context key_maxsize key_headers key__proxy key__proxy_headers key__proxy_config key_socket_options key__socks_options key_assert_hostname key_assert_fingerprint key_server_hostname key_blocksize } class PoolManager { __enter__(self) -&amp;gt; _SelfT __exit__(self, exc_type, exc_val, exc_tb) --&amp;gt; Literal[False] _new_pool(self, scheme: str, host: str, port: str, request_context: Optional[Dict[str, Any]] = None) -&amp;gt; HTTPConnectionPool clear(self) -&amp;gt; None connection_from_host(self, host: Optional[str], port: Optional[int] = None, scheme: Optional[str] = &amp;quot;http&amp;quot;, pool_kwargs: Optional[Dict[str, Any]] = None) -&amp;gt; HTTPConnectionPool connection_from_context(self, request_context: Dict[str, Any]) -&amp;gt; HTTPConnectionPool connection_from_pool_key(self, pool_key: PoolKey, request_context: Dict[str, Any]) -&amp;gt; HTTPConnectionPool connection_from_url(self, url: str, pool_kwargs: Optional[Dict[str, Any]] = None) -&amp;gt; HTTPConnectionPool _merge_pool_kwargs(self, overrider: Optional[Dict[str, Any]]) -&amp;gt; Dict[str, Any] _proxy_requires_url_absolute_form(self, parsed_url: Url) -&amp;gt; bool urlopen(self, method: str, url: str, redirect: bool = True, **kw: Any) -&amp;gt; BaseHTTPResponse } class ProxyManager { connection_from_host(self, host: Optional[str], port: Optional[int] = None, scheme: Optional[str] = &amp;quot;http&amp;quot;, pool_kwargs: Optional[Dict[str, Any]] = None) -&amp;gt; HTTPConnectionPool _set_proxy_headers(self, url: str, headers: Optional[Mapping[str, str]] = None) -&amp;gt; Mapping[str, str] urlopen(self, method: str, url: str, redirect: bool = True, **kw: Any) -&amp;gt; BaseHTTPResponse } RequestMethods &amp;lt;|-- PoolManager PoolManager &amp;lt;|-- ProxyManager @enduml fields class RequestField { _name _filename headers classmethod from_tuples(cls, fieldname: str, value ) -&amp;gt; RequestField _render_part(self, name: str, value) -&amp;gt; str _render_parts(self, header_parts: Union[Dict[str, str], Sequence[Tuple[str, str]]) -&amp;gt; str render_headers(self) -&amp;gt; str make_multipart(self, content_disposition: Optional[str] = None, content_type: Optional[str] = None, content_loation: Optional[str] = None) -&amp;gt; None } exceptions @startuml Excepption &amp;lt;|-- HTTPError Warning &amp;lt;|-- HTTPWarning PoolError &amp;lt;|-- HTTPError PoolError &amp;lt;|-- RequestError HTTPError &amp;lt;|-- SSLERROR HTTPError &amp;lt;|-- ProxyError HTTPError &amp;lt;|-- DecodeError HTTPError &amp;lt;|-- ProtocolError HTTPError &amp;lt;|-- ConnectionError RequestError &amp;lt;|-- MaxRetryError RequestError &amp;lt;|-- HostChangeError HTTPError &amp;lt;|-- TimeoutStateError HTTPError &amp;lt;|-- TimeoutError TimeoutError &amp;lt;|-- ReadTimeoutError TimeoutError &amp;lt;|-- ConnectTimeoutError ConnectTimeoutError &amp;lt;|-- NewConnectionError NewConnectionError &amp;lt;|-- NameResolutionError PoolError &amp;lt;|-- EmptyPoolError PoolError &amp;lt;|-- FullPoolError @enduml connection pool @startuml class ConnectionPool { __str__(self) -&amp;gt; str __enter__(self) -&amp;gt; SelfT __exit__(self, exec_type, exc_value, exc_tb) -&amp;gt; &amp;quot;Literal[False]&amp;quot; close(self) -&amp;gt; None } class HTTPConnectionPool { _new_conn(self) -&amp;gt; HTTPConnection _get_conn(self, timeout: Optional[float] = None) -&amp;gt; HTTPConnection _put_conn(self, conn: Optional[HTTPConnection]) -&amp;gt; None _validate_conn(self, conn: HTTPConnection) -&amp;gt; None _prepare_proxy(self, conn: HTTPConnection) -&amp;gt; None _get_timeout(self, timeout) -&amp;gt; Timeout _raise_timeout(self, err, url: str, timeout_value) -&amp;gt; None _make_request(self, conn: HTTPConnection, method: str, url: str, timeout: float, chunked: bool = False, **httplib_request_kw: Any) -&amp;gt; _HttplibHTTPResponse _absolute_url(self, path: str) -&amp;gt; str close(self) -&amp;gt; None is_same_host(self, url: str) -&amp;gt; bool urlopen(self, method: str, url: str, body, headers, retries, redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw: Any) -&amp;gt; BaseHTTPResponse } class HTTPSConnectionPool { _prepare_conn(self, conn: HTTPSConnection) -&amp;gt; HTTPConnection _prepase_proxy(self, conn: HTTPSConnection) -&amp;gt; None _new_conn(self) -&amp;gt; HTTPConnection _validate_conn(self, conn: HTTPConnection) -&amp;gt; None } ConnectionPool &amp;lt;|-- HTTPConnectionPool RequestMethods &amp;lt;|-- HTTPConnectionPool HTTPConnectionPool &amp;lt;|-- HTTPSConnectionPool @enduml connection @startuml NamedTuple &amp;lt;|-- ProxyConfig class ProxyConfig { ssl_context use_forwarding_for_https } _HTTPConnection &amp;lt;|-- HTTPConnection class HTTPConnection { host : property _new_conn(self) -&amp;gt; socket.</description></item></channel></rss>