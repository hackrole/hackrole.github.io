<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on Hackrole's Blog</title><link>https://hackrole.github.io/tags/golang/</link><description>Recent content in golang on Hackrole's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2020 &lt;a href="https://www.wangchucheng.com/">C. Wang&lt;/a> and &lt;a href="https://www.ruiqima.com/">R. Ma&lt;/a></copyright><lastBuildDate>Sun, 18 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://hackrole.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>ch12: 反射reflection</title><link>https://hackrole.github.io/post/golang_reflection/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://hackrole.github.io/post/golang_reflection/</guid><description>introduce 在编译是不知道类型的情况下，可在运行时查看值，调用方法，更新变量，以及对布局进行操作的机制.
反射让我们把类型当作头等值
动态类型 vs 动态值
反射定义了两个重要的类型 reflect.Type, reflect.Value
reflect.Type 类型描述符 接口值的动态类型也是类型描述符
满足fmt.Stringer接口
t := reflect.TypeOf(3) fmt.Println(t.String()) fmt.Println(t) // 反射总是返回具体类型 var w io.Writer = os.Stdout fmt.Println(reflect.TypeOf(w)) // return os.File int int *os.File reflect.Value v := reflect.ValueOf(3) fmt.Println(v) // this will handle reflect.Value fmt.Println(&amp;quot;%v\n&amp;quot;, v) // implement the fmt.Stringer interface, but only return `Type` if not string fmt.Println(v.String()) // get `Value` Type t := v.Type() fmt.Println(t.String()) // the reverse operator x := v.Interface() // return `interface{}` i := x.</description></item><item><title>visit struct tag</title><link>https://hackrole.github.io/post/golang_programming_note/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://hackrole.github.io/post/golang_programming_note/</guid><description>package main import ( &amp;quot;fmt&amp;quot; &amp;quot;http&amp;quot; &amp;quot;reflect&amp;quot; ) // search ... func search(resp http.ResponseWriter, req *http.Request) { var data struct { Labels []string `http:&amp;quot;1&amp;quot;` MaxResults int `http:&amp;quot;max&amp;quot;` Exact bool `http:&amp;quot;x&amp;quot;` } data.MaxResults = 10 if err := Unpack(req, &amp;amp;data); err != nil { http.Error(resp, err.Error(), http.StatusBadRequest) return } fmt.Fprintf(resp, &amp;quot;Search: %+v\n&amp;quot;, data) } // Unpack func Unpack(req *http.Request, ptr interface{}) error { if err := req.ParseForm(); err != nil { return err } fields := make(map[string]reflect.</description></item></channel></rss>