<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithms on Hackrole's Blog</title><link>https://hackrole.github.io/tags/algorithms/</link><description>Recent content in algorithms on Hackrole's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2020 &lt;a href="https://www.wangchucheng.com/">C. Wang&lt;/a> and &lt;a href="https://www.ruiqima.com/">R. Ma&lt;/a></copyright><lastBuildDate>Sun, 18 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://hackrole.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>dynamic programming</title><link>https://hackrole.github.io/post/data_structure_and_algorithm_dynamic_programming/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://hackrole.github.io/post/data_structure_and_algorithm_dynamic_programming/</guid><description>introduce 动态规划是通过组合子问题的解来解决整个问题，不同与分治算法，动态规划的子问题不是相互独立的， 动态规划通过对每个子子问题只计算一次来优化计算过程。
动态规划一般用于最优化问题求解.
一般步骤 描述最优解结构 递归定义最优化解的值, 定义递归式(最重要的一部) 按自底向上的方式计算最优解 构造一个最优解(一般不需要，或第三部已经保留了过程) 能应用动态规划的两个主要特征 问题包含最优子结构,父问题的最优解需要子问题的最优解 子问题重叠，应用动态规划可以提高性能 动态规划的变形: 备忘 自顶向下的计算策略.
使用低效但是容易理解的递归算法，同时对子问题解进行缓存。
TODO实例1: 生产线问题 TODO实例2: 矩阵乘法 TODO实例3: 最长公共子序列 TODO实例4: 编辑距离</description></item><item><title>greed programming</title><link>https://hackrole.github.io/post/greed_programming/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://hackrole.github.io/post/greed_programming/</guid><description/></item><item><title>sort algorithms note</title><link>https://hackrole.github.io/post/sort/</link><pubDate>Fri, 08 Mar 2019 10:05:30 +0000</pubDate><guid>https://hackrole.github.io/post/sort/</guid><description>heap sort in-place sort algorithms
O(nlgn)
过程要点 left/right/parent可以通过(2n, 2n+1, n/2)算出.
一般数组索引从0开始，left/right/parent为(2n+1, 2n+2, (n-1)/2)
建堆算法 O(n)
堆有一个cap和一个len(当前长度)
步骤 # max-heap 保持堆性质 def max_heap(h, i): l = left(i) r = right(i) if l &amp;lt;= heap_size(A) &amp;amp;&amp;amp; A[l] &amp;gt; A[i]: lg = l if r &amp;lt;= heap_size(A) &amp;amp;&amp;amp; A[r] &amp;gt; A[i]: lg = r if lg != i: A[i], A[lg] = A[lg], A[i] max_heap(h, lg) # build-heap 建堆 def build_heap(h): hs = len(h) for i = hs/2; i &amp;gt;= 0; i--: build_heap(h, i) # heap-sort 排序 def heap_sort(A): build_heap(A) for i = len(A); i&amp;gt;0; i--: A[0], A[i] = A[i], A[0] A.</description></item></channel></rss>